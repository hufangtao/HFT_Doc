# 常见问题
## TCP解决粘包、半包问题
### TCP协议
TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议

```
面向连接：在应用TCP协议进行通信之前双方通常需要通过三次握手来建立TCP连接，连接建立后才能进行正常的数据传输，因此广播和多播不会承载在TCP协议上。
```
```
可靠性：TCP处于多跳通信的IP层之上，而IP层并不可靠。在TCP层看来就有四种常见传输错误问题，分别是比特错误(packet bit errors)、包乱序(packet reordering)、包重复(packet duplication)、丢包(packet erasure或称为packet drops)。因此TCP要提供可靠的传输，就需要具有超时重传、窗口管理、流量控制、拥塞控制等功能。
```
- 丢包：TCP通过超时重传和快速重传保证数据包的正确传输
- 包乱序：TCP接收端会缓存接收到的乱序到达数据，重排后再向应用层提供有序的数据。
- TCP维持一个`发送窗口`变量，动态调整发送速率以使用接收端缓存限制和网络拥塞情况，避免网络拥塞或者接收端缓存满而大量丢包的问题。

```
字节流式：应用层发送的数据会在TCP的发送端缓存起来，统一分片或者打包。到接收端的时候接收端也是直接按照字节流将数据传递给应用层。作为对比，同样是传输层的协议，UDP并不会对应用层的数据包进行打包和分票的操作，一般一个应用层的数据包就对应一个UDP包。
```

### TCP协议头
![blockchain](https://github.com/hufangtao/HFT_Doc/blob/master/Pictures/740952-20161107132809311-2059896218.png?raw=true "图片hover描述")

```
TCP头中的相关字段顺序解释如下：

TCP源端口(Source Port)：16位的源端口其中包含发送方应用程序对应的端口。源端口和源IP地址标示报文发送端的地址。

TCP目的端口(Destination port)：16位的目的端口域定义传输的目的。这个端口指明报文接收计算机上的应用程序地址接口。

TCP的源端口、目的端口、以及IP层的源IP地址、目的IP地址四元组唯一的标识了一个TCP连接，一个IP地址和一个端口号的组合叫做一个endpoint或者socket。也即一对endpoint或者一对socket唯一的标识了一个TCP连接。接收端的TCP层就是根据不同的端口号来将数据包传送给应用层的不同程序，这个过程叫做解复用(demultiplex)。相应的发送端会把应用层不同程序的数据映射到不同的端口号，这个过程叫做复用(multiplex)。

TCP序列号（序列码SN,Sequence　Number）：32位的序列号标识了TCP报文中第一个byte在对应方向的传输中对应的字节序号。当SYN出现，序列码实际上是初始序列码（ISN），而第一个数据字节是ISN+1，单位是byte。比如发送端发送的一个TCP包净荷(不包含TCP头)为12byte，SN为5，则发送端接着发送的下一个数据包的时候，SN应该设置为5+12=17。通过系列号，TCP接收端可以识别出重复接收到的TCP包，从而丢弃重复包，同时对于乱序数据包也可以依靠系列号进行重排序，进而对高层提供有序的数据流。另外SYN标志和FIN标志在逻辑上也占用一个byte，当SYN标志位有效的时候，该字段也称为ISN(initial sequence number)，详细请参考后续的TCP连接管理。

TCP应答号(Acknowledgment   Number简称ACK Number或简称为ACK Field)：32位的ACK Number标识了报文发送端期望接收的字节序列。如果设置了ACK控制位，这个值表示一个准备接收的包的序列码，注意是准备接收的包，比如当前接收端接收到一个净荷为12byte的数据包，SN为5，则发送端可能会回复一个确认收到的数据包，如果这个数据包之前的数据也都已经收到了，这个数据包中的ACK Number则设置为12+5=17，表示17byte之前的数据都已经收到了。在举一个例子，如果在这个数据包之前有个SN为3，净荷为2byte的数据包丢失，则在接受端接收到这个SN为5的乱序数据包的时候，协议要求接收端必须要回复一个ACK确认包，这个确认包中的Ack Number只能设置为3。

头长(Header Length)：4位包括TCP头大小，指示TCP头的长度，即数据从何处开始。最大为15，单位是32比特(32-bit word)。

保留(Reserved)：4位值域，这些位必须是0。为了将来定义新的用途所保留，其中RFC3540将Reserved字段中的最后一位定义为Nonce标志。后续拥塞控制部分的讲解我们会简单介绍Nonce标志位。

标志(Code Bits)：8位标志位，下面介绍。

窗口大小(Window Size)：16位，该值指示了从Ack Number开始还愿意接收多少byte的数据量，也即用来表示当前接收端的接收窗还有多少剩余空间。用于TCP的流量控制。

校验位(Checksum)：16位TCP头。发送端基于数据内容计算一个数值，接收端要与发送端数值结果完全一样，才能证明数据的有效性。接收端checksum校验失败的时候会直接丢掉这个数据包。CheckSum是根据伪头+TCP头+TCP数据三部分进行计算的。另外对于大的数据包，checksum并不能可靠的反应比特错误，应用层应该再添加自己的校验方式。

优先指针（紧急,Urgent  Pointer）：16位，指向后面是优先数据的字节，在URG标志设置了时才有效。如果URG标志没有被设置，紧急域作为填充。加快处理标示为紧急的数据段。

选项(Option)：长度不定，但长度必须以是32bits的整数倍。常见的选项包括MSS、SACK、Timestamp等等，后续的内容会分别介绍相关选项。
```

### 为什么会出现粘包、半包的问题
TCP把应用层的数据块看成一连串无结构的字节流，没有边界。而且在TCP帧结构中我们知道，TCP并没有标记包长度。
`Steven,W.R. <TCP/IP Illustrated Volume 1 >：UDP length字段是冗余的，它等于IP total length 减去IP header。`
基于这两点，在使用TCP传输数据时，才会出现粘包或者拆包的可能。
但是IP协议头是有长度的，又由于IP是不可靠的，传输过程中如果出现`IP头-TCP头-部分数据`这样的数据包，TCP会认为数据包正常，但是数据其实已经丢失。
没有明确边界，导致接收端无法知道如何解析

### 如何解决
1. 消息定长。例如100字节。
2. 在包尾部增加回车或者空格符等特殊字符进行分割，典型的如FTP协议
3. 将消息分为消息头和消息尾。

服务器开发一般使用3方式解决粘包和半包问题

### 应用层消息包的设计如何保证完整性
比如在传输过程、解析过程中，程序失误怎么办
设置头尾魔数

### 为什么需要保活
考虑一种情况，tcp连接创建后，在一段时间内双方没有发送任何数据。
1. 如何判断对方是否还在线。TCP并不能侦测到非正常断开

#### TCP的保活机制
保活机制是由一个保活计时器实现。


## 参考
5种IO模型 [https://www.cnblogs.com/dunitian/p/10099343.html](https://www.cnblogs.com/dunitian/p/10099343.html "超链接hover描述")

