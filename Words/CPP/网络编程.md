---
title: 网络编程
---

## TODO List
1. IO模型C++代码

## 基本概念

### 同步与异步
```
同步是指一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成。
```
```
异步是指不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作。然后继续执行下面代码逻辑，只要自己完成了整个任务就算完成了（异步一般使用状态、通知和回调）
```
```
区别：读写数据的方式不同。
同步：主动拷贝IO数据到用户进程
异步：只要拷贝IO数据完成的通知，拷贝过程由内核完成
```

### 阻塞与非阻塞
```
阻塞是指调用结果返回之前，当前线程会被挂起，一直处于等待消息通知，不能够执行其他业务
```
```
非阻塞是指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回
```
```
区别：需要访问的IO数据未就绪的情况下，是否需要等待
```

## IO模型
```
一个输入操作通常包括两个不同阶段：
1. 等待数据准备好；例如：等待数据报分组到达
2. 从内核向进程复制数据
```

由于存在这两个阶段，Linux产生了下面五种IO模型（以socket为例）
1. 阻塞式IO

   - 当用户进程调用了recvfrom等方法时，内核进入IO的第1个阶段：准备数据（内核需要等待足够的数据再拷贝）这个过程需要等待，用户进程阻塞等待内核将数据准备好。然后用户进程同步拷贝到用户地址空间。

2. 非阻塞IO
   - 用户进程发起`read`请求，如果内核种的数据还没有准备好，那么它不会阻塞等待，而是立即返回一个`error`：EWOULDBLOCK、EAGAIN
   - 用户进程判断是一个`error`时，进程知道数据还没准备好，于是它可以再次发送`read`请求
   - 在某次`read`请求时，发现数据已经准备好，那么同步将数据拷贝到用户内存
   - 非阻塞IO模式下，用户进程需要轮询查看Linux内核是否准备好了
      
      ![blockchain](https://github.com/hufangtao/HFT_Doc/blob/master/Pictures/1127869-20181210212858009-948984805.png?raw=true "图片hover描述")
3. IO多路复用
   - 通过一种机制，一个进程同时监视多个文件描述符。一旦某个文件描述符就绪，能够通知程序进行响应的读写操作，而不需要程序轮询。
   - 常用的IO多路复用：`select`、`poll`和`epoll`
      
      ![blockchain](https://github.com/hufangtao/HFT_Doc/blob/master/Pictures/1127869-20181210212908314-1267377747.png?raw=true "图片hover描述")

4. 信号驱动IO
   - 内核文件描述符就绪之后，通过信号通知用户进程，用户进程通过系统调用读取数据
   - 此方法属于同步IO，因为从内核到用户空间的读取是由用户进程负责的，一般用信号量实现。
      
      ![blockchain](https://github.com/hufangtao/HFT_Doc/blob/master/Pictures/1127869-20181210212934040-13536334.png?raw=true "图片hover描述")
5. 异步IO（POSIX的aio_系列函数）
   - 用户进程发起read操作之后，立即就开始去做其他事情。内核收到一个异步`IO read`之后，不会阻塞用户进程
   - 内核等待数据准备完成，然后将数据拷贝到用户内存。当一切都完成之后，内核向用户进程发送一个`signal`，通知用户进程`read`操作完成
      
      ![blockchain](https://github.com/hufangtao/HFT_Doc/blob/master/Pictures/1127869-20181210212944334-1184572641.png?raw=true "图片hover描述")

同步： IO复用 select/poll/epoll
异步： Linux：AIO  Windos：IOCP  其它一些网络库

## 网络库

### Boost ASIO

# 常见问题

## TCP解决粘包、半包问题
### TCP协议
TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议

```
面向连接：在应用TCP协议进行通信之前双方通常需要通过三次握手来建立TCP连接，连接建立后才能进行正常的数据传输，因此广播和多播不会承载在TCP协议上。
```
```
可靠性：TCP处于多跳通信的IP层之上，而IP层并不可靠。在TCP层看来就有四种常见传输错误问题，分别是比特错误(packet bit errors)、包乱序(packet reordering)、包重复(packet duplication)、丢包(packet erasure或称为packet drops)。因此TCP要提供可靠的传输，就需要具有超时重传、窗口管理、流量控制、拥塞控制等功能。
```
- 丢包：TCP通过超时重传和快速重传保证数据包的正确传输
- 包乱序：TCP接收端会缓存接收到的乱序到达数据，重排后再向应用层提供有序的数据。
- TCP维持一个`发送窗口`变量，动态调整发送速率以使用接收端缓存限制和网络拥塞情况，避免网络拥塞或者接收端缓存满而大量丢包的问题。

```
字节流式：应用层发送的数据会在TCP的发送端缓存起来，统一分片或者打包。到接收端的时候接收端也是直接按照字节流将数据传递给应用层。作为对比，同样是传输层的协议，UDP并不会对应用层的数据包进行打包和分票的操作，一般一个应用层的数据包就对应一个UDP包。
```

### TCP协议头
![blockchain](https://github.com/hufangtao/HFT_Doc/blob/master/Pictures/740952-20161107132809311-2059896218.png?raw=true "图片hover描述")

```
TCP头中的相关字段顺序解释如下：

TCP源端口(Source Port)：16位的源端口其中包含发送方应用程序对应的端口。源端口和源IP地址标示报文发送端的地址。

TCP目的端口(Destination port)：16位的目的端口域定义传输的目的。这个端口指明报文接收计算机上的应用程序地址接口。

TCP的源端口、目的端口、以及IP层的源IP地址、目的IP地址四元组唯一的标识了一个TCP连接，一个IP地址和一个端口号的组合叫做一个endpoint或者socket。也即一对endpoint或者一对socket唯一的标识了一个TCP连接。接收端的TCP层就是根据不同的端口号来将数据包传送给应用层的不同程序，这个过程叫做解复用(demultiplex)。相应的发送端会把应用层不同程序的数据映射到不同的端口号，这个过程叫做复用(multiplex)。

TCP序列号（序列码SN,Sequence　Number）：32位的序列号标识了TCP报文中第一个byte在对应方向的传输中对应的字节序号。当SYN出现，序列码实际上是初始序列码（ISN），而第一个数据字节是ISN+1，单位是byte。比如发送端发送的一个TCP包净荷(不包含TCP头)为12byte，SN为5，则发送端接着发送的下一个数据包的时候，SN应该设置为5+12=17。通过系列号，TCP接收端可以识别出重复接收到的TCP包，从而丢弃重复包，同时对于乱序数据包也可以依靠系列号进行重排序，进而对高层提供有序的数据流。另外SYN标志和FIN标志在逻辑上也占用一个byte，当SYN标志位有效的时候，该字段也称为ISN(initial sequence number)，详细请参考后续的TCP连接管理。

TCP应答号(Acknowledgment   Number简称ACK Number或简称为ACK Field)：32位的ACK Number标识了报文发送端期望接收的字节序列。如果设置了ACK控制位，这个值表示一个准备接收的包的序列码，注意是准备接收的包，比如当前接收端接收到一个净荷为12byte的数据包，SN为5，则发送端可能会回复一个确认收到的数据包，如果这个数据包之前的数据也都已经收到了，这个数据包中的ACK Number则设置为12+5=17，表示17byte之前的数据都已经收到了。在举一个例子，如果在这个数据包之前有个SN为3，净荷为2byte的数据包丢失，则在接受端接收到这个SN为5的乱序数据包的时候，协议要求接收端必须要回复一个ACK确认包，这个确认包中的Ack Number只能设置为3。

头长(Header Length)：4位包括TCP头大小，指示TCP头的长度，即数据从何处开始。最大为15，单位是32比特(32-bit word)。

保留(Reserved)：4位值域，这些位必须是0。为了将来定义新的用途所保留，其中RFC3540将Reserved字段中的最后一位定义为Nonce标志。后续拥塞控制部分的讲解我们会简单介绍Nonce标志位。

标志(Code Bits)：8位标志位，下面介绍。

窗口大小(Window Size)：16位，该值指示了从Ack Number开始还愿意接收多少byte的数据量，也即用来表示当前接收端的接收窗还有多少剩余空间。用于TCP的流量控制。

校验位(Checksum)：16位TCP头。发送端基于数据内容计算一个数值，接收端要与发送端数值结果完全一样，才能证明数据的有效性。接收端checksum校验失败的时候会直接丢掉这个数据包。CheckSum是根据伪头+TCP头+TCP数据三部分进行计算的。另外对于大的数据包，checksum并不能可靠的反应比特错误，应用层应该再添加自己的校验方式。

优先指针（紧急,Urgent  Pointer）：16位，指向后面是优先数据的字节，在URG标志设置了时才有效。如果URG标志没有被设置，紧急域作为填充。加快处理标示为紧急的数据段。

选项(Option)：长度不定，但长度必须以是32bits的整数倍。常见的选项包括MSS、SACK、Timestamp等等，后续的内容会分别介绍相关选项。
```

### 为什么会出现粘包、半包的问题
TCP把应用层的数据块看成一连串无结构的字节流，没有边界。而且在TCP帧结构中我们知道，TCP并没有标记包长度。
`Steven,W.R. <TCP/IP Illustrated Volume 1 >：UDP length字段是冗余的，它等于IP total length 减去IP header。`
基于这两点，在使用TCP传输数据时，才会出现粘包或者拆包的可能。
但是IP协议头是有长度的，又由于IP是不可靠的，传输过程中如果出现`IP头-TCP头-部分数据`这样的数据包，TCP会认为数据包正常，但是数据其实已经丢失。
没有明确边界，导致接收端无法知道如何解析

### 如何解决
1. 消息定长。例如100字节。
2. 在包尾部增加回车或者空格符等特殊字符进行分割，典型的如FTP协议
3. 将消息分为消息头和消息尾。

服务器开发一般使用3方式解决粘包和半包问题

### 应用层消息包的设计如何保证完整性
比如在传输过程、解析过程中，程序失误怎么办
设置头尾魔数

## 参考
5种IO模型 [https://www.cnblogs.com/dunitian/p/10099343.html](https://www.cnblogs.com/dunitian/p/10099343.html "超链接hover描述")

